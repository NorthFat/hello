/// @file impl_zmq_modern.cc
/// @brief 现代 C++17 ZMQ 后端实现源文件
/// @author Generated by C++17 Modernization Project
/// @date 2024

#include "impl_zmq_modern.h"

#include <iostream>
#include <mutex>

// ============================================================================
// 静态成员初始化
// ============================================================================

// ZMQContextManager 的静态成员
std::unique_ptr<void, ZMQContextDeleter> ZMQContextManager::context_;
std::once_flag ZMQContextManager::init_flag_;

// ============================================================================
// ZMQSubSocket<T> 模板实现
// ============================================================================

/// @brief 显式模板实例化
/// 
/// 为了支持多种套接字类型，我们需要显式实例化模板类。
/// 这确保模板代码在编译时被正确生成。
/// 
/// 根据实际使用情况，可以添加更多的模板实例化。

// 示例：为 MSGQSubSocket 实例化（假设存在）
// 如果代码中有其他子套接字类，也需要类似的实例化
// template class ZMQSubSocket<YourSubSocketClass>;

// ============================================================================
// 功能性实现
// ============================================================================

/// @brief ZMQ 套接字工厂函数
/// 
/// 这个辅助函数创建一个新的 ZMQ 套接字。
/// 使用它可以实现无序混合提升的分离关注点。
/// 
/// @param context ZMQ 上下文
/// @param socket_type ZMQ 套接字类型（如 ZMQ_SUB）
/// 
/// @return 新创建的 ZMQ 套接字指针，失败返回 nullptr
inline void* zmq_socket_create(void* context, int socket_type) noexcept {
  if (!context) {
    std::cerr << "Error: Cannot create socket with null context" << std::endl;
    return nullptr;
  }
  
  void* socket = zmq_socket(context, socket_type);
  if (!socket) {
    std::cerr << "Error: zmq_socket() failed with errno " << errno << std::endl;
  }
  
  return socket;
}

// ============================================================================
// 调试和测试辅助
// ============================================================================

/// @brief 获取 ZMQ 错误描述
/// 
/// @return 当前 ZMQ 错误的字符串描述
inline std::string zmq_error_string() noexcept {
  return std::string(zmq_strerror(errno));
}

// ============================================================================
// 版本和功能检查
// ============================================================================

/// @brief 检查 ZMQ 库版本
/// 
/// @return ZMQ 版本号（主.次.补丁）
inline std::string get_zmq_version() noexcept {
  int major, minor, patch;
  zmq_version(&major, &minor, &patch);
  
  std::string version = std::to_string(major) + "." + 
                       std::to_string(minor) + "." + 
                       std::to_string(patch);
  return version;
}

// ============================================================================
// 单元测试和示例代码
// ============================================================================

/// @brief ZMQ 上下文管理器示例
/// 
/// 演示如何使用 ZMQContextManager 获取全局 ZMQ 上下文
/// 
/// @return 示例返回值（0 = 成功）
int example_zmq_context_usage() noexcept {
  try {
    // 获取全局上下文（线程安全）
    void* context = ZMQContextManager::get_context();
    if (!context) {
      std::cerr << "Failed to get ZMQ context" << std::endl;
      return -1;
    }
    
    std::cout << "ZMQ version: " << get_zmq_version() << std::endl;
    std::cout << "Successfully obtained ZMQ context" << std::endl;
    
    // 上下文由 ZMQContextManager 管理，不需要手动释放
    return 0;
    
  } catch (const std::exception& e) {
    std::cerr << "Exception in example_zmq_context_usage(): " << e.what() << std::endl;
    return -1;
  }
}

/// @brief ZMQ 套接字创建示例
/// 
/// 演示如何安全创建 ZMQ 套接字
/// 
/// @return 示例返回值（0 = 成功）
int example_zmq_socket_creation() noexcept {
  try {
    // 获取全局上下文
    void* context = ZMQContextManager::get_context();
    if (!context) {
      std::cerr << "Failed to get ZMQ context" << std::endl;
      return -1;
    }
    
    // 使用 RAII 管理套接字生命周期
    auto socket = std::unique_ptr<void, ZMQSocketDeleter>(
      zmq_socket_create(context, ZMQ_SUB)
    );
    
    if (!socket) {
      std::cerr << "Failed to create ZMQ socket: " << zmq_error_string() << std::endl;
      return -1;
    }
    
    std::cout << "Successfully created ZMQ socket (SUB type)" << std::endl;
    
    // 套接字在作用域结束时自动关闭
    return 0;
    
  } catch (const std::exception& e) {
    std::cerr << "Exception in example_zmq_socket_creation(): " << e.what() << std::endl;
    return -1;
  }
}

/// @brief ZMQ 轮询器示例
/// 
/// 演示如何使用 ZMQPoller 轮询多个套接字
/// 
/// @return 示例返回值（0 = 成功）
int example_zmq_poller_usage() noexcept {
  try {
    // 创建轮询器（自动获取全局上下文）
    ZMQPoller poller;
    
    std::cout << "Successfully created ZMQPoller" << std::endl;
    std::cout << "Registered sockets: " << poller.get_socket_count() << std::endl;
    
    // 轮询（即使没有套接字也是安全的）
    auto ready = poller.poll(100);  // 100ms 超时
    std::cout << "Poll returned " << ready.size() << " ready events" << std::endl;
    
    return 0;
    
  } catch (const std::exception& e) {
    std::cerr << "Exception in example_zmq_poller_usage(): " << e.what() << std::endl;
    return -1;
  }
}

// ============================================================================
// 主入口点（可选，用于测试）
// ============================================================================

/// @brief 测试入口点
/// 
/// 可以编译成独立的可执行文件用于测试
/// 
/// 编译命令：
/// g++ -std=c++17 -o test_zmq impl_zmq_modern.cc -lzmq
/// 
/// @return 0 = 所有测试通过，非 0 = 某个测试失败
int main_test() noexcept {
  std::cout << "\n=== ZMQ 现代化实现测试 ===" << std::endl;
  std::cout << "ZMQ Version: " << get_zmq_version() << std::endl << std::endl;
  
  // 测试 1: 上下文管理
  std::cout << "Test 1: ZMQ Context Manager" << std::endl;
  if (example_zmq_context_usage() != 0) {
    std::cerr << "FAILED: Context manager test" << std::endl;
    return 1;
  }
  std::cout << "PASSED: Context manager test" << std::endl << std::endl;
  
  // 测试 2: 套接字创建
  std::cout << "Test 2: ZMQ Socket Creation" << std::endl;
  if (example_zmq_socket_creation() != 0) {
    std::cerr << "FAILED: Socket creation test" << std::endl;
    return 2;
  }
  std::cout << "PASSED: Socket creation test" << std::endl << std::endl;
  
  // 测试 3: 轮询器
  std::cout << "Test 3: ZMQ Poller" << std::endl;
  if (example_zmq_poller_usage() != 0) {
    std::cerr << "FAILED: Poller test" << std::endl;
    return 3;
  }
  std::cout << "PASSED: Poller test" << std::endl << std::endl;
  
  std::cout << "=== 所有测试通过！===" << std::endl;
  return 0;
}

// ============================================================================
// 工具函数：参数验证
// ============================================================================

/// @brief 验证端点字符串
/// 
/// 检查端点是否符合 ZMQ 端点格式要求
/// 
/// @param endpoint 端点字符串
/// 
/// @return true = 有效，false = 无效
bool is_valid_zmq_endpoint(const std::string& endpoint) noexcept {
  if (endpoint.empty() || endpoint.length() > 256) {
    return false;
  }
  
  // ZMQ 端点应该以 tcp:// 或类似的协议前缀开头
  return endpoint.find("://") != std::string::npos;
}

/// @brief 验证地址字符串
/// 
/// 检查地址是否有效（用于发布-订阅过滤）
/// 
/// @param address 地址字符串
/// 
/// @return true = 有效，false = 无效
bool is_valid_zmq_address(const std::string& address) noexcept {
  if (address.empty() || address.length() > 256) {
    return false;
  }
  
  // 地址可以是任意字节串，但长度有限制
  return true;
}

// ============================================================================
// 工具函数：事件转换
// ============================================================================

/// @brief 将事件类型字符串转换为 ZMQ 事件掩码
/// 
/// @param event_type 事件类型字符串（"POLLIN", "POLLOUT", etc.）
/// 
/// @return ZMQ 事件掩码，未知类型返回 0
int zmq_event_from_string(const std::string& event_type) noexcept {
  if (event_type == "POLLIN") return ZMQ_POLLIN;
  if (event_type == "POLLOUT") return ZMQ_POLLOUT;
  if (event_type == "POLLERR") return ZMQ_POLLERR;
  return 0;
}

/// @brief 将 ZMQ 事件掩码转换为字符串
/// 
/// @param events ZMQ 事件掩码
/// 
/// @return 事件类型字符串
std::string zmq_event_to_string(int events) noexcept {
  std::string result;
  
  if (events & ZMQ_POLLIN) result += "POLLIN ";
  if (events & ZMQ_POLLOUT) result += "POLLOUT ";
  if (events & ZMQ_POLLERR) result += "POLLERR ";
  
  if (!result.empty()) {
    result.pop_back();  // 移除最后的空格
  }
  
  return result;
}

// ============================================================================
// 性能监控（可选）
// ============================================================================

/// @brief 记录性能指标
/// 
/// 用于监控 ZMQ 操作的性能
struct PerformanceMetrics {
  long long socket_create_count = 0;  ///< 创建的套接字数
  long long socket_delete_count = 0;  ///< 删除的套接字数
  long long poll_count = 0;            ///< 轮询次数
  long long error_count = 0;           ///< 错误次数
};

// 全局性能指标
static thread_local PerformanceMetrics g_metrics;

/// @brief 获取性能指标
/// 
/// @return 当前线程的性能指标
PerformanceMetrics get_performance_metrics() noexcept {
  return g_metrics;
}

/// @brief 重置性能指标
void reset_performance_metrics() noexcept {
  g_metrics = PerformanceMetrics();
}

/// @brief 打印性能指标
void print_performance_metrics() noexcept {
  std::cout << "\n=== ZMQ 性能指标 ===" << std::endl;
  std::cout << "Socket create count: " << g_metrics.socket_create_count << std::endl;
  std::cout << "Socket delete count: " << g_metrics.socket_delete_count << std::endl;
  std::cout << "Poll count: " << g_metrics.poll_count << std::endl;
  std::cout << "Error count: " << g_metrics.error_count << std::endl;
}
