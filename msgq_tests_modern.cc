/// @file msgq_tests_modern.cc
/// @brief 现代 C++17 消息队列测试套件
/// @author Generated by C++17 Modernization Project
/// @date 2024

#include <catch2/catch.hpp>
#include <msgq/msgq.h>

#include <cstring>
#include <filesystem>
#include <chrono>
#include <iostream>
#include <sstream>
#include <random>
#include <memory>

// ============================================================================
// 测试工具类
// ============================================================================

/// @brief 测试日志系统
class TestLogger {
public:
  enum class Level {
    Debug = 0,
    Info = 1,
    Warning = 2,
    Error = 3
  };
  
  /// @brief 设置日志级别
  static void set_level(Level level) {
    log_level_ = level;
  }
  
  /// @brief 调试级日志
  static void debug(const std::string& msg) {
    if (log_level_ <= Level::Debug) {
      std::cout << "[DEBUG] " << msg << std::endl;
    }
  }
  
  /// @brief 信息级日志
  static void info(const std::string& msg) {
    if (log_level_ <= Level::Info) {
      std::cout << "[INFO] " << msg << std::endl;
    }
  }
  
  /// @brief 警告级日志
  static void warning(const std::string& msg) {
    if (log_level_ <= Level::Warning) {
      std::cerr << "[WARNING] " << msg << std::endl;
    }
  }
  
  /// @brief 错误级日志
  static void error(const std::string& msg) {
    if (log_level_ <= Level::Error) {
      std::cerr << "[ERROR] " << msg << std::endl;
    }
  }

private:
  static Level log_level_;
};

TestLogger::Level TestLogger::log_level_ = TestLogger::Level::Info;

/// @brief 消息 RAII 包装器
/// 
/// 确保消息资源在所有情况下都能正确释放，包括异常情况
class MessageGuard {
private:
  msgq_msg_t& msg_;
  
public:
  /// @brief 构造函数
  /// @param msg 要管理的消息引用
  explicit MessageGuard(msgq_msg_t& msg) noexcept : msg_(msg) {}
  
  /// @brief 析构函数
  /// 
  /// 自动调用 msgq_msg_close 清理消息
  ~MessageGuard() noexcept {
    msgq_msg_close(&msg_);
  }
  
  // 禁用拷贝
  MessageGuard(const MessageGuard&) = delete;
  MessageGuard& operator=(const MessageGuard&) = delete;
  
  // 允许移动
  MessageGuard(MessageGuard&&) noexcept = default;
  MessageGuard& operator=(MessageGuard&&) noexcept = default;
};

/// @brief 测试上下文 Fixture
/// 
/// 提供唯一的测试隔离，每个测试使用不同的队列名
class MessageQueueTestFixture {
protected:
  std::string queue_name;
  std::string queue_path;
  
public:
  /// @brief 构造函数
  /// 
  /// 生成唯一的队列名和路径
  MessageQueueTestFixture() {
    // 生成唯一的测试 ID
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1000000, 9999999);
    
    int test_id = dis(gen);
    queue_name = "test_queue_" + std::to_string(test_id);
    
    // Linux 特定：/dev/shm
    // macOS: /tmp
    // Windows: %TEMP%
    #ifdef __APPLE__
    queue_path = "/tmp/" + queue_name;
    #elif _WIN32
    queue_path = std::string(std::getenv("TEMP")) + "\\" + queue_name;
    #else
    queue_path = "/dev/shm/" + queue_name;
    #endif
    
    TestLogger::debug("Created test context with queue: " + queue_name);
  }
  
  /// @brief 析构函数
  /// 
  /// 自动清理测试产生的文件
  virtual ~MessageQueueTestFixture() {
    try {
      if (std::filesystem::exists(queue_path)) {
        std::filesystem::remove(queue_path);
        TestLogger::debug("Cleaned up queue file: " + queue_path);
      }
    } catch (const std::exception& e) {
      TestLogger::warning(std::string("Failed to cleanup: ") + e.what());
    }
  }
  
  /// @brief 清理旧的队列文件
  void cleanup_old_queue() const {
    try {
      if (std::filesystem::exists(queue_path)) {
        std::filesystem::remove(queue_path);
        TestLogger::debug("Removed old queue file");
      }
    } catch (const std::exception& e) {
      TestLogger::error(std::string("Cleanup error: ") + e.what());
    }
  }
};

/// @brief 性能计时器
class PerformanceTimer {
private:
  std::chrono::high_resolution_clock::time_point start_time;
  std::string name;
  
public:
  /// @brief 构造函数
  /// @param test_name 测试名称
  explicit PerformanceTimer(const std::string& test_name)
    : name(test_name) {
    start_time = std::chrono::high_resolution_clock::now();
    TestLogger::info("Starting: " + name);
  }
  
  /// @brief 析构函数
  /// 
  /// 输出执行时间
  ~PerformanceTimer() {
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
      end_time - start_time
    );
    
    std::stringstream ss;
    ss << name << " completed in " << duration.count() << "ms";
    TestLogger::info(ss.str());
  }
  
  /// @brief 获取已用时间（毫秒）
  long long elapsed_ms() const {
    auto now = std::chrono::high_resolution_clock::now();
    return std::chrono::duration_cast<std::chrono::milliseconds>(
      now - start_time
    ).count();
  }
};

// ============================================================================
// 单元测试
// ============================================================================

TEST_CASE("ALIGN", "[unit]") {
  REQUIRE(ALIGN(0) == 0);
  REQUIRE(ALIGN(1) == 8);
  REQUIRE(ALIGN(7) == 8);
  REQUIRE(ALIGN(8) == 8);
  REQUIRE(ALIGN(99999) == 100000);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_msg_init_size", "[unit]") {
  TestLogger::debug("Testing message initialization with size");
  
  const size_t msg_size = 30;
  msgq_msg_t msg;

  msgq_msg_init_size(&msg, msg_size);
  REQUIRE(msg.size == msg_size);

  MessageGuard guard(msg);  // 自动清理
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_msg_init_data", "[unit]") {
  TestLogger::debug("Testing message initialization with data");
  
  const size_t msg_size = 30;
  auto data = std::make_unique<char[]>(msg_size);

  for (size_t i = 0; i < msg_size; i++) {
    data[i] = static_cast<char>(i);
  }

  msgq_msg_t msg;
  msgq_msg_init_data(&msg, data.get(), msg_size);

  REQUIRE(msg.size == msg_size);
  REQUIRE(memcmp(msg.data, data.get(), msg_size) == 0);

  MessageGuard guard(msg);  // 自动清理
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_init_subscriber", "[unit]") {
  TestLogger::debug("Testing subscriber initialization");
  
  cleanup_old_queue();
  
  msgq_queue_t q;
  msgq_new_queue(&q, queue_name.c_str(), 1024);
  
  REQUIRE(*q.num_readers == 0);

  q.reader_id = 1;
  *q.read_valids[0] = false;
  *q.read_pointers[0] = ((uint64_t)1 << 32);
  *q.write_pointer = 255;

  msgq_init_subscriber(&q);
  
  REQUIRE(q.read_conflate == false);
  REQUIRE(*q.read_valids[0] == true);
  REQUIRE((*q.read_pointers[0] >> 32) == 0);
  REQUIRE((*q.read_pointers[0] & 0xFFFFFFFF) == 255);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_msg_send first message", "[unit]") {
  TestLogger::debug("Testing first message send");
  
  cleanup_old_queue();
  
  msgq_queue_t q;
  msgq_new_queue(&q, queue_name.c_str(), 1024);
  msgq_init_publisher(&q);

  REQUIRE(*q.write_pointer == 0);

  size_t msg_size = 128;

  SECTION("Aligned message size") {
    TestLogger::debug("Testing aligned message");
  }
  
  SECTION("Unaligned message size") {
    TestLogger::debug("Testing unaligned message");
    msg_size--;
  }
  
  auto data = std::make_unique<char[]>(msg_size);
  for (size_t i = 0; i < msg_size; i++) {
    data[i] = static_cast<char>(i);
  }

  msgq_msg_t msg;
  msgq_msg_init_data(&msg, data.get(), msg_size);
  MessageGuard guard(msg);

  msgq_msg_send(&msg, &q);
  
  REQUIRE(*(int64_t *)q.data == static_cast<int64_t>(msg_size));
  REQUIRE(*q.write_pointer == 128 + sizeof(int64_t));
  REQUIRE(memcmp(q.data + sizeof(int64_t), data.get(), msg_size) == 0);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_msg_send test wraparound", "[unit]") {
  TestLogger::debug("Testing message wraparound");
  
  cleanup_old_queue();
  
  msgq_queue_t q;
  msgq_new_queue(&q, queue_name.c_str(), 1024);
  msgq_init_publisher(&q);

  REQUIRE((*q.write_pointer & 0xFFFFFFFF) == 0);
  REQUIRE((*q.write_pointer >> 32) == 0);

  const size_t msg_size = 120;
  msgq_msg_t msg;
  msgq_msg_init_size(&msg, msg_size);
  MessageGuard guard(msg);

  for (int i = 0; i < 8; i++) {
    msgq_msg_send(&msg, &q);
  }
  
  // 检查第 8 条消息在开头
  REQUIRE((*q.write_pointer & 0xFFFFFFFF) == msg_size + sizeof(int64_t));
  
  // 检查周期计数
  REQUIRE((*q.write_pointer >> 32) == 1);

  // 检查环绕标记
  char *tag_location = q.data;
  tag_location += 7 * (msg_size + sizeof(int64_t));
  REQUIRE(*(int64_t *)tag_location == -1);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_msg_recv test wraparound", "[unit]") {
  TestLogger::debug("Testing message receive wraparound");
  
  cleanup_old_queue();
  
  msgq_queue_t q_pub, q_sub;
  msgq_new_queue(&q_pub, queue_name.c_str(), 1024);
  msgq_new_queue(&q_sub, queue_name.c_str(), 1024);

  msgq_init_publisher(&q_pub);
  msgq_init_subscriber(&q_sub);

  REQUIRE((*q_pub.write_pointer >> 32) == 0);
  REQUIRE((*q_sub.read_pointers[0] >> 32) == 0);

  const size_t msg_size = 120;
  msgq_msg_t msg1;
  msgq_msg_init_size(&msg1, msg_size);
  MessageGuard guard1(msg1);

  SECTION("Check cycle counter after reset") {
    for (int i = 0; i < 8; i++) {
      msgq_msg_send(&msg1, &q_pub);
    }

    msgq_msg_t msg2;
    msgq_msg_recv(&msg2, &q_sub);
    REQUIRE(msg2.size == 0);  // 读取器必须重置
    MessageGuard guard2(msg2);
  }
  
  SECTION("Check cycle counter while keeping up with writer") {
    for (int i = 0; i < 8; i++) {
      msgq_msg_send(&msg1, &q_pub);

      msgq_msg_t msg2;
      msgq_msg_recv(&msg2, &q_sub);
      REQUIRE(msg2.size > 0);
      MessageGuard guard2(msg2);
    }
  }

  REQUIRE((*q_sub.read_pointers[0] >> 32) == 1);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_msg_send test invalidation", "[unit]") {
  TestLogger::debug("Testing message invalidation");
  
  cleanup_old_queue();
  
  msgq_queue_t q_pub, q_sub;
  msgq_new_queue(&q_pub, queue_name.c_str(), 1024);
  msgq_new_queue(&q_sub, queue_name.c_str(), 1024);

  msgq_init_publisher(&q_pub);
  msgq_init_subscriber(&q_sub);
  *q_sub.write_pointer = (uint64_t)1 << 32;

  REQUIRE(*q_sub.read_valids[0] == true);

  SECTION("read pointer in tag") {
    *q_sub.read_pointers[0] = 0;
  }
  
  SECTION("read pointer in data section") {
    *q_sub.read_pointers[0] = 64;
  }
  
  SECTION("read pointer in wraparound section") {
    *q_pub.write_pointer = ((uint64_t)1 << 32) | 1000;
    *q_sub.read_pointers[0] = 1020;
  }

  msgq_msg_t msg;
  msgq_msg_init_size(&msg, 128);
  MessageGuard guard(msg);
  
  msgq_msg_send(&msg, &q_pub);

  REQUIRE(*q_sub.read_valids[0] == false);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "msgq_init_subscriber init 2 subscribers", "[unit]") {
  TestLogger::debug("Testing multiple subscriber initialization");
  
  cleanup_old_queue();
  
  msgq_queue_t q1, q2;
  msgq_new_queue(&q1, queue_name.c_str(), 1024);
  msgq_new_queue(&q2, queue_name.c_str(), 1024);

  *q1.num_readers = 0;

  REQUIRE(*q1.num_readers == 0);
  REQUIRE(*q2.num_readers == 0);

  msgq_init_subscriber(&q1);
  REQUIRE(*q1.num_readers == 1);
  REQUIRE(*q2.num_readers == 1);
  REQUIRE(q1.reader_id == 0);

  msgq_init_subscriber(&q2);
  REQUIRE(*q1.num_readers == 2);
  REQUIRE(*q2.num_readers == 2);
  REQUIRE(q2.reader_id == 1);
}

// ============================================================================
// 集成测试
// ============================================================================

TEST_CASE_METHOD(MessageQueueTestFixture, "Write 1 msg, read 1 msg", "[integration]") {
  TestLogger::info("Running basic send/receive integration test");
  PerformanceTimer timer("Basic send/receive");
  
  cleanup_old_queue();
  
  const size_t msg_size = 128;
  msgq_queue_t writer, reader;

  msgq_new_queue(&writer, queue_name.c_str(), 1024);
  msgq_new_queue(&reader, queue_name.c_str(), 1024);

  msgq_init_publisher(&writer);
  msgq_init_subscriber(&reader);

  msgq_msg_t outgoing_msg;
  msgq_msg_init_size(&outgoing_msg, msg_size);
  MessageGuard guard1(outgoing_msg);

  for (size_t i = 0; i < msg_size; i++) {
    outgoing_msg.data[i] = static_cast<char>(i);
  }

  REQUIRE(msgq_msg_send(&outgoing_msg, &writer) == static_cast<int>(msg_size));

  msgq_msg_t incoming_msg1;
  REQUIRE(msgq_msg_recv(&incoming_msg1, &reader) == static_cast<int>(msg_size));
  REQUIRE(memcmp(incoming_msg1.data, outgoing_msg.data, msg_size) == 0);
  MessageGuard guard2(incoming_msg1);
  
  msgq_msg_t incoming_msg2;
  REQUIRE(msgq_msg_recv(&incoming_msg2, &reader) == 0);
  MessageGuard guard3(incoming_msg2);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "Write 2 msg, read 2 msg - conflate = false", "[integration]") {
  TestLogger::info("Running write/read 2 messages (no conflate)");
  PerformanceTimer timer("Write/read 2 messages");
  
  cleanup_old_queue();
  
  const size_t msg_size = 128;
  msgq_queue_t writer, reader;

  msgq_new_queue(&writer, queue_name.c_str(), 1024);
  msgq_new_queue(&reader, queue_name.c_str(), 1024);

  msgq_init_publisher(&writer);
  msgq_init_subscriber(&reader);

  msgq_msg_t outgoing_msg;
  msgq_msg_init_size(&outgoing_msg, msg_size);
  MessageGuard guard1(outgoing_msg);

  for (size_t i = 0; i < msg_size; i++) {
    outgoing_msg.data[i] = static_cast<char>(i);
  }

  REQUIRE(msgq_msg_send(&outgoing_msg, &writer) == static_cast<int>(msg_size));
  REQUIRE(msgq_msg_send(&outgoing_msg, &writer) == static_cast<int>(msg_size));

  msgq_msg_t incoming_msg1;
  REQUIRE(msgq_msg_recv(&incoming_msg1, &reader) == static_cast<int>(msg_size));
  REQUIRE(memcmp(incoming_msg1.data, outgoing_msg.data, msg_size) == 0);
  MessageGuard guard2(incoming_msg1);
  
  msgq_msg_t incoming_msg2;
  REQUIRE(msgq_msg_recv(&incoming_msg2, &reader) == static_cast<int>(msg_size));
  REQUIRE(memcmp(incoming_msg2.data, outgoing_msg.data, msg_size) == 0);
  MessageGuard guard3(incoming_msg2);
}

TEST_CASE_METHOD(MessageQueueTestFixture, "Write 2 msg, read 2 msg - conflate = true", "[integration]") {
  TestLogger::info("Running write/read 2 messages (with conflate)");
  PerformanceTimer timer("Write/read 2 messages with conflate");
  
  cleanup_old_queue();
  
  const size_t msg_size = 128;
  msgq_queue_t writer, reader;

  msgq_new_queue(&writer, queue_name.c_str(), 1024);
  msgq_new_queue(&reader, queue_name.c_str(), 1024);

  msgq_init_publisher(&writer);
  msgq_init_subscriber(&reader);
  reader.read_conflate = true;

  msgq_msg_t outgoing_msg;
  msgq_msg_init_size(&outgoing_msg, msg_size);
  MessageGuard guard1(outgoing_msg);

  for (size_t i = 0; i < msg_size; i++) {
    outgoing_msg.data[i] = static_cast<char>(i);
  }

  REQUIRE(msgq_msg_send(&outgoing_msg, &writer) == static_cast<int>(msg_size));
  REQUIRE(msgq_msg_send(&outgoing_msg, &writer) == static_cast<int>(msg_size));

  msgq_msg_t incoming_msg1;
  REQUIRE(msgq_msg_recv(&incoming_msg1, &reader) == static_cast<int>(msg_size));
  REQUIRE(memcmp(incoming_msg1.data, outgoing_msg.data, msg_size) == 0);
  MessageGuard guard2(incoming_msg1);
  
  msgq_msg_t incoming_msg2;
  REQUIRE(msgq_msg_recv(&incoming_msg2, &reader) == 0);
  MessageGuard guard3(incoming_msg2);
}

// ============================================================================
// 性能和压力测试
// ============================================================================

TEST_CASE_METHOD(MessageQueueTestFixture, "Performance: 1 publisher, 1 slow subscriber", "[performance][integration]") {
  TestLogger::info("Running performance test");
  PerformanceTimer timer("1 pub, 1 slow sub performance");
  
  cleanup_old_queue();
  
  msgq_queue_t writer, reader;

  msgq_new_queue(&writer, queue_name.c_str(), 1024);
  msgq_new_queue(&reader, queue_name.c_str(), 1024);

  msgq_init_publisher(&writer);
  msgq_init_subscriber(&reader);

  int n_received = 0;
  int n_skipped = 0;
  const int iterations = 100000;

  for (int i = 0; i < iterations; i++) {
    msgq_msg_t outgoing_msg;
    uint64_t data = i;
    msgq_msg_init_data(&outgoing_msg, (char *)&data, sizeof(uint64_t));
    MessageGuard guard1(outgoing_msg);
    
    msgq_msg_send(&outgoing_msg, &writer);

    if (i % 10 == 0) {
      msgq_msg_t msg1;
      msgq_msg_recv(&msg1, &reader);
      MessageGuard guard2(msg1);

      if (msg1.size == 0) {
        n_skipped++;
      } else {
        n_received++;
      }
    }
  }

  // 性能基准验证
  REQUIRE(n_received + n_skipped > 0);  // 至少有些消息被处理
  
  double throughput = iterations / (timer.elapsed_ms() / 1000.0);
  TestLogger::info("Throughput: " + std::to_string(static_cast<int>(throughput)) + " msg/sec");
}

TEST_CASE_METHOD(MessageQueueTestFixture, "Stress: 1 publisher, 2 subscribers", "[stress][integration]") {
  TestLogger::info("Running stress test with multiple subscribers");
  PerformanceTimer timer("1 pub, 2 subs stress");
  
  cleanup_old_queue();
  
  msgq_queue_t writer, reader1, reader2;

  msgq_new_queue(&writer, queue_name.c_str(), 1024);
  msgq_new_queue(&reader1, queue_name.c_str(), 1024);
  msgq_new_queue(&reader2, queue_name.c_str(), 1024);

  msgq_init_publisher(&writer);
  msgq_init_subscriber(&reader1);
  msgq_init_subscriber(&reader2);

  const int iterations = 3072;
  for (int i = 0; i < iterations; i++) {
    msgq_msg_t outgoing_msg;
    uint64_t data = i;
    msgq_msg_init_data(&outgoing_msg, (char *)&data, sizeof(uint64_t));
    MessageGuard guard1(outgoing_msg);
    
    msgq_msg_send(&outgoing_msg, &writer);

    msgq_msg_t msg1, msg2;
    msgq_msg_recv(&msg1, &reader1);
    msgq_msg_recv(&msg2, &reader2);
    MessageGuard guard2(msg1);
    MessageGuard guard3(msg2);

    REQUIRE(msg1.size == sizeof(uint64_t));
    REQUIRE(msg2.size == sizeof(uint64_t));
    REQUIRE(*(uint64_t *)msg1.data == static_cast<uint64_t>(i));
    REQUIRE(*(uint64_t *)msg2.data == static_cast<uint64_t>(i));
  }
}

// ============================================================================
// 测试初始化
// ============================================================================

/// @brief 测试配置
/// 这个函数在所有测试运行前调用
int main(int argc, char* argv[]) {
  TestLogger::info("=== MessageQ Modern Test Suite ===");
  TestLogger::set_level(TestLogger::Level::Info);
  
  // 运行 Catch2 测试
  int result = Catch::Session().run(argc, argv);
  
  TestLogger::info("=== Test Suite Complete ===");
  return result;
}
