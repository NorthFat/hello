/// @file impl_zmq_modern.h
/// @brief 现代 C++17 ZMQ 后端实现（资源管理、异常安全）
/// @author Generated by C++17 Modernization Project
/// @date 2024

#pragma once

#include <memory>
#include <vector>
#include <stdexcept>
#include <string>
#include <mutex>
#include <cassert>
#include <zmq.h>

// ============================================================================
// 自定义删除器（RAII 资源管理）
// ============================================================================

/// @brief ZMQ 上下文的自定义删除器
/// 
/// 确保 zmq_ctx_destroy() 被正确调用，即使发生异常
class ZMQContextDeleter {
public:
  /// @brief 删除 ZMQ 上下文
  /// @param context ZMQ 上下文指针
  void operator()(void* context) const noexcept {
    if (context) {
      zmq_ctx_destroy(context);
    }
  }
};

/// @brief ZMQ 套接字的自定义删除器
/// 
/// 确保 zmq_close() 被正确调用，即使发生异常
class ZMQSocketDeleter {
public:
  /// @brief 关闭 ZMQ 套接字
  /// @param socket ZMQ 套接字指针
  void operator()(void* socket) const noexcept {
    if (socket) {
      zmq_close(socket);
    }
  }
};

// ============================================================================
// ZMQ 上下文管理器（单例 + 线程安全）
// ============================================================================

/// @brief 全局 ZMQ 上下文管理器
/// 
/// 使用单例模式确保全局只有一个 ZMQ 上下文，避免资源浪费。
/// 线程安全的初始化保证即使在多线程环境中也能安全使用。
class ZMQContextManager {
private:
  // 全局上下文（使用 unique_ptr 自动管理生命周期）
  static std::unique_ptr<void, ZMQContextDeleter> context_;
  static std::once_flag init_flag_;
  
  // 删除构造函数（单例模式）
  ZMQContextManager() = delete;
  
public:
  /// @brief 获取全局 ZMQ 上下文
  /// 
  /// 线程安全的 get_context() 使用 std::once_flag 确保上下文只初始化一次。
  /// 
  /// @return ZMQ 上下文指针
  /// @throw std::runtime_error 如果创建上下文失败
  static void* get_context() {
    std::call_once(init_flag_, []() {
      void* ctx = zmq_ctx_new();
      if (!ctx) {
        throw std::runtime_error("Failed to create ZMQ context");
      }
      context_ = std::unique_ptr<void, ZMQContextDeleter>(ctx);
    });
    
    return context_.get();
  }
};

// ============================================================================
// ZMQ 子套接字模板类
// ============================================================================

/// @brief ZMQ 订阅套接字实现
/// 
/// 使用模板支持多种套接字类型，通过 std::unique_ptr 自动管理
/// ZMQ 套接字的生命周期。
template<typename TSubSocket>
class ZMQSubSocket: public TSubSocket {
private:
  /// 套接字状态枚举
  enum class State {
    kDisconnected = 0,  ///< 断开连接
    kConnecting = 1,    ///< 连接中
    kConnected = 2,     ///< 已连接
    kDisconnecting = 3  ///< 断开中
  };
  
  State state = State::kDisconnected;
  std::unique_ptr<void, ZMQSocketDeleter> zmq_socket;
  mutable std::mutex state_lock;
  
public:
  /// @brief 构造函数
  /// 
  /// 初始化 ZMQ 套接字为断开连接状态
  ZMQSubSocket() noexcept
    : state(State::kDisconnected), zmq_socket(nullptr) {}
  
  /// @brief 析构函数
  /// 
  /// zmq_socket 的智能指针会自动调用 ZMQSocketDeleter::operator()
  /// 来正确清理 ZMQ 资源
  ~ZMQSubSocket() noexcept override = default;
  
  // 删除拷贝构造和赋值
  ZMQSubSocket(const ZMQSubSocket&) = delete;
  ZMQSubSocket& operator=(const ZMQSubSocket&) = delete;
  
  // 允许移动
  ZMQSubSocket(ZMQSubSocket&& other) noexcept = default;
  ZMQSubSocket& operator=(ZMQSubSocket&& other) noexcept = default;
  
  /// @brief 连接到 ZMQ 端点
  /// 
  /// 通过 RAII 和异常安全保证，确保资源在任何情况下都能正确释放。
  /// 如果 connect() 失败，zmq_socket 会自动释放，不会泄漏。
  /// 
  /// @param context 套接字上下文
  /// @param endpoint 端点标识符
  /// @param address 订阅地址
  /// 
  /// @return 0 成功，非 0 失败
  /// 
  /// @throw std::invalid_argument 参数无效
  /// @throw std::runtime_error 连接失败
  int connect(void* context, const std::string& endpoint, const std::string& address) override {
    try {
      // 参数验证
      if (!context) {
        throw std::invalid_argument("Context cannot be null");
      }
      
      if (endpoint.empty()) {
        throw std::invalid_argument("Endpoint cannot be empty");
      }
      
      if (address.empty()) {
        throw std::invalid_argument("Address cannot be empty");
      }
      
      if (endpoint.length() > 256) {
        throw std::invalid_argument("Endpoint too long (max 256 chars)");
      }
      
      if (address.length() > 256) {
        throw std::invalid_argument("Address too long (max 256 chars)");
      }
      
      std::lock_guard<std::mutex> lock(state_lock);
      
      // 检查状态
      if (state == State::kConnected) {
        return 0;  // 已连接
      }
      
      if (state != State::kDisconnected) {
        throw std::runtime_error("Cannot connect: invalid state");
      }
      
      // 状态转移：连接中
      state = State::kConnecting;
      
      // 创建临时套接字（异常时自动释放）
      auto temp_socket = std::unique_ptr<void, ZMQSocketDeleter>(
        zmq_socket(context, ZMQ_SUB)
      );
      
      if (!temp_socket) {
        state = State::kDisconnected;
        throw std::runtime_error("Failed to create ZMQ socket");
      }
      
      // 订阅（异常时自动释放 temp_socket）
      int r = zmq_setsockopt(temp_socket.get(), ZMQ_SUBSCRIBE,
                             address.data(), address.length());
      if (r != 0) {
        state = State::kDisconnected;
        throw std::runtime_error("Failed to set subscription");
      }
      
      // 连接（异常时自动释放 temp_socket）
      r = zmq_connect(temp_socket.get(), endpoint.c_str());
      if (r != 0) {
        state = State::kDisconnected;
        throw std::runtime_error("Failed to connect socket");
      }
      
      // 调用父类 connect()
      r = TSubSocket::connect(context, endpoint, address);
      if (r != 0) {
        state = State::kDisconnected;
        throw std::runtime_error("Parent connect failed");
      }
      
      // 只在完全成功时转移所有权
      zmq_socket = std::move(temp_socket);
      state = State::kConnected;
      
      return 0;
      
    } catch (const std::invalid_argument& e) {
      std::cerr << "Invalid argument in connect(): " << e.what() << std::endl;
      return -1;
    } catch (const std::runtime_error& e) {
      std::cerr << "Runtime error in connect(): " << e.what() << std::endl;
      return -2;
    } catch (const std::exception& e) {
      std::cerr << "Unexpected error in connect(): " << e.what() << std::endl;
      return -3;
    }
  }
  
  /// @brief 断开连接
  /// 
  /// 状态安全的断开连接。确保状态机的正确转移。
  /// 
  /// @return 0 成功，非 0 失败
  int disconnect() noexcept override {
    try {
      std::lock_guard<std::mutex> lock(state_lock);
      
      if (state == State::kDisconnected) {
        return 0;  // 已断开
      }
      
      state = State::kDisconnecting;
      
      // 关闭套接字（调用 ZMQSocketDeleter）
      zmq_socket.reset();
      
      // 调用父类 disconnect()
      int r = TSubSocket::disconnect();
      
      state = State::kDisconnected;
      return r;
      
    } catch (const std::exception& e) {
      std::cerr << "Error in disconnect(): " << e.what() << std::endl;
      state = State::kDisconnected;
      zmq_socket.reset();
      return -1;
    }
  }
  
  /// @brief 检查是否已连接
  /// 
  /// @return true 已连接，false 未连接
  bool is_connected() const noexcept {
    std::lock_guard<std::mutex> lock(state_lock);
    return state == State::kConnected;
  }
  
  /// @brief 接收消息
  /// 
  /// @param timeout_ms 超时时间（毫秒）
  /// @return 接收的消息
  std::string receive(int timeout_ms = -1) const override {
    if (zmq_socket) {
      char buffer[256];
      int size = zmq_recv(zmq_socket.get(), buffer, sizeof(buffer) - 1, 
                         timeout_ms >= 0 ? 0 : ZMQ_DONTWAIT);
      if (size > 0) {
        buffer[size] = '\0';
        return std::string(buffer);
      }
    }
    return "";
  }
};

// ============================================================================
// ZMQ 轮询器
// ============================================================================

/// @brief ZMQ 轮询器实现
/// 
/// 使用 ZMQContextManager 获取全局 ZMQ 上下文，避免重复创建。
/// 提供 const 正确的接口。
class ZMQPoller {
private:
  void* zmq_context = nullptr;
  std::vector<void*> zmq_sockets;
  std::vector<int> socket_events;
  
public:
  /// @brief 构造函数
  /// 
  /// 获取全局 ZMQ 上下文（不拥有，由 ZMQContextManager 管理）
  /// 
  /// @throw std::runtime_error 如果获取上下文失败
  explicit ZMQPoller() {
    zmq_context = ZMQContextManager::get_context();
    if (!zmq_context) {
      throw std::runtime_error("Failed to get ZMQ context");
    }
  }
  
  /// @brief 析构函数
  /// 
  /// zmq_context 由 ZMQContextManager 管理，不需要手动释放
  ~ZMQPoller() noexcept = default;
  
  // 删除拷贝
  ZMQPoller(const ZMQPoller&) = delete;
  ZMQPoller& operator=(const ZMQPoller&) = delete;
  
  // 允许移动
  ZMQPoller(ZMQPoller&&) noexcept = default;
  ZMQPoller& operator=(ZMQPoller&&) noexcept = default;
  
  /// @brief 轮询 ZMQ 套接字（只读操作）
  /// 
  /// @param timeout_ms 超时时间（毫秒）
  /// @return 就绪的事件列表
  std::vector<int> poll(int timeout_ms = -1) const {
    if (zmq_sockets.empty()) {
      return {};
    }
    
    // 创建轮询项
    std::vector<zmq_pollitem_t> items(zmq_sockets.size());
    for (size_t i = 0; i < zmq_sockets.size(); ++i) {
      items[i].socket = zmq_sockets[i];
      items[i].fd = 0;
      items[i].events = socket_events[i];
      items[i].revents = 0;
    }
    
    // 轮询
    int r = zmq_poll(items.data(), static_cast<int>(items.size()), timeout_ms);
    if (r <= 0) {
      return {};
    }
    
    // 收集就绪的事件
    std::vector<int> ready;
    for (size_t i = 0; i < items.size(); ++i) {
      if (items[i].revents & (ZMQ_POLLIN | ZMQ_POLLOUT)) {
        ready.push_back(static_cast<int>(i));
      }
    }
    
    return ready;
  }
  
  /// @brief 注册套接字（修改操作）
  /// 
  /// @param socket ZMQ 套接字指针
  /// @param events 关注的事件（如 ZMQ_POLLIN）
  /// 
  /// @throw std::invalid_argument 套接字为空
  void register_socket(void* socket, int events = ZMQ_POLLIN) {
    if (!socket) {
      throw std::invalid_argument("Socket cannot be null");
    }
    
    zmq_sockets.push_back(socket);
    socket_events.push_back(events);
  }
  
  /// @brief 获取套接字数量（只读操作）
  /// 
  /// @return 已注册的套接字数量
  int get_socket_count() const noexcept {
    return static_cast<int>(zmq_sockets.size());
  }
  
  /// @brief 清空所有套接字
  void clear() noexcept {
    zmq_sockets.clear();
    socket_events.clear();
  }
};

#endif  // IMPL_ZMQ_MODERN_H_
